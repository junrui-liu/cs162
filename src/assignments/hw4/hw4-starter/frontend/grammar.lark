?start: prog

prog: _decl* main

main: "main" ":" ty "=" expr

_separated{item, sep}:
    | item (sep item)*
    | item (sep item)* sep

_decl: def
    | eqn

def: "def" GLOBAL ":" ty "=" expr -> def_
eqn: "type" GLOBAL "=" ty -> eqn

?ty: arr
?arr: ty_atom "->" arr -> ty_fun
    | ty_atom
?ty_atom: "Nat" -> ty_nat
    | "Bool" -> ty_bool
    | GLOBAL -> ty_name
    | "+" "{" _separated{ty_field, ","} "}" -> ty_sum
    | "(" _tys ")" -> ty_prod
_tys: _separated{ty, ","}
ty_field: LABEL ":" ty

?expr: "\\" LOCAL "." expr -> lam
    | "\\" "{" _separated{branch, ","} "}" -> lam_match
    | "let" LOCAL [":" ty] "=" expr "in" expr -> let
    | ite
    | unpack
    | switch
    | match
    | annot
?annot: annot ":" ty  -> annot
    | arith "==" arith -> eq
    | arith
?arith: arith "+" term -> add
    | arith "-" term -> sub
    | term
?term: term "*" app_like -> mul
    | app_like
?app_like: app atom_label -> app
    | inj
?app: app atom_label -> app
    | atom
?inj: LABEL inj -> inj
    | atom_label
?atom_label: atom
    | LABEL -> inj_unit
?atom: NAT -> nat
    | "True" -> true
    | "False" -> false
    | LOCAL -> var
    | GLOBAL -> abbrev
    | "(" _separated{expr, ","} ")" -> pack

ite: "if" expr "then" expr "else" expr -> ite
unpack: "let" "(" _locals ")" "=" expr "in" expr -> unpack
switch: "switch" expr "{" _separated{case, ","} "}" -> switch
case: LABEL LOCAL ":" expr -> case_
match: "match" expr "{" _separated{branch, ","} "}" -> match_
branch: pat ":" expr -> branch
?pat: LOCAL -> pat_local
    | LABEL -> pat_inj_unit
    | LABEL pat -> pat_inj
    | "(" _separated{pat, ","} ")" -> pat_pack

_locals: _separated{LOCAL, ","}

%import common.LCASE_LETTER
%import common.UCASE_LETTER
%import common.LETTER
%import common.DIGIT
%import common.WS

WORD_LETTER: "_" | LETTER | DIGIT
LOCAL: "_" | (LCASE_LETTER WORD_LETTER*)
GLOBAL: UCASE_LETTER WORD_LETTER*
LABEL: "'" WORD_LETTER+
NAT: DIGIT+

%ignore WS

COMMENT: "#" /[^\n]/*
%ignore COMMENT